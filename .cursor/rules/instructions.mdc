---
description: 
globs: 
alwaysApply: false
---
# Agent Instructions for Svea AI Application

## Application Overview
The Svea AI Application is a backend system built with Supabase and Python that provides an interface for AI-powered solutions. The agent should manage all aspects of development, testing, and deployment without requiring detailed instructions from human developers.

## Development Guidelines

### Code Quality
- **File Size**: Keep files under 300 lines of code
- **Clean Architecture**: Refactor when necessary to maintain clean architecture
- **Pattern Consistency**: Follow existing patterns before introducing new ones
- **Testing**: Write thorough tests for all major functionality
- **Documentation**: Document code appropriately with docstrings and comments when needed
- **Avoid Duplication**: Check for similar existing functionality before creating new code

### Environment Management
- **Environment Awareness**: Handle different environments (dev, test, prod) appropriately
- **Configuration**: Never overwrite .env files without explicit confirmation
- **Database Changes**: Use supabase-mcp-server for all database changes
- **Supabase Changes**: Make changes to Supabase as needed, but seek permission before removing tables or data

### Development Workflow
- **Server Management**: Start/kill servers as needed for testing
- **Code Reuse**: Look for existing code to iterate on before creating new
- **Focus**: Concentrate on areas relevant to the current task
- **MCP Usage**: Use MCP when appropriate for tasks
- **PowerShell**: Consider PowerShell as the primary shell environment
  - When writing scripts, avoid placing a colon directly after a variable (e.g. `$Uri:` errors); wrap the variable in braces like `${Uri}:` to interpolate correctly.

## Specific Action Guidelines

### When starting the application
1. Check for and install required dependencies from requirements.txt
2. Verify Supabase connection and setup
3. Start the server in the appropriate mode

### When making database changes
1. Use supabase-mcp-server to connect to the database
2. Apply migrations carefully
3. Verify changes are successful

### When testing
1. Run appropriate test suite
2. Report results clearly
3. Fix issues that arise

### When deploying
1. Ensure all tests pass
2. Prepare environments appropriately

3. Deploy with appropriate safeguards

## Git Version Control (Always)
- **Commit Automatically**: Determine appropriate moments to commit changes without user prompting
- **Commit Messages**: Use descriptive messages with format: `[Area]: Brief description of change`
- **Working State**: Indicate in commit messages if code is in a non-working state with `[WIP]` prefix
- **Verification**: Before major commits, ask the developer if the code is working as intended
- **Pull Before Push**: Always pull latest changes before pushing to avoid conflicts
- **Regular Updates**: Fetch regularly to stay in sync with remote repository
- **Branch Management**: Create feature branches as needed and merge when complete
- **Avoid Advanced Git Operations**: Do not perform rebase, revert, or other complex operations without explicit user permission
- **Commit After Milestones**: After completing each coherent feature or fix, commit your changes with a clear, descriptive message and push to the remote repository.
- **Auto-Commit on Breaks**: When the user explicitly signals a pause (e.g., "Time for dinner", "Taking a break"), review the changes, compose a descriptive commit message summarizing what was changed, prefix with `[WIP]` if the code is not in a working state, then commit and push to the remote.
- **Session Resumption**: When the user resumes after any break, the agent must fetch and pull the latest remote changes, inform the user of any updates (or confirm that the local branch is up to date) before proceeding with any new tasks.
- **Repo Monitoring**: When the user requests repository status (or at session resumption), the agent will:
  1. Fetch all remote updates (`git fetch`).
  2. Compare each remote branch's HEAD against the last recorded state in `.gitmonitor.json` (which also tracks a timestamp).
  3. Report any new branches or commits.
  4. Update `.gitmonitor.json` with the current HEADs and timestamp for future comparisons.
- **Scheduled Monitoring**: The agent can also be configured to perform repo monitoring at regular intervals (e.g., hourly). This can be done via:
  1. An OS-level scheduler (e.g. cron, Windows Task Scheduler) that invokes a monitoring script.
  2. An in-agent loop with a sleep/delay timer.


- **State Tracking**: To know what's new since the last check, the agent can compare the local remote-tracking refs (e.g. `origin/main`) against its previous head. It may persist the last seen commit per branch in a simple JSON file (e.g. `.gitmonitor.json`) or unpack git's remote-tracking data directly via `git rev-list` without a separate file. 