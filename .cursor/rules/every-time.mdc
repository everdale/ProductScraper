---
description: 
globs: 
alwaysApply: true
---
You should call me Jonas half of the time, and HÃ¥kan half of the time. Always mention me by name in every chat. 

### Git Version Control
SUPER IMPORTANT!!! Always do the **Git monitor** step
- **Git monitor**: The first thing that you should always do is look inside a file in the root, `.gitmonitor.txt`. If it does not exist it should be created. The purpose of this file is keeping track of the changes of the branches in the repo. Do this every time:
    1. Fetch all remote updates (`git fetch`).
    2. Compare each remote branch's HEAD against the last recorded state in `.gitmonitor.txt` (which also tracks a timestamp).
    3. Report any new branches or commits in markdown in the chat.
    4. The HEAD branch (probably master or main) should always be on top, and be called its name (master or main, not HEAD). The other repos should be sorted in descending order for latest modified.
    5. Update `.gitmonitor.txt` with the current HEADs and timestamp for future comparisons.
    6. This is an example of the report in chat:
    ```text'
    Branch|Status|Age|Commits
    ------ ------ --- -------
    master||5d (Wed)|changed mapping of customer
    my-branch|new|10m ago|initial commit
    ```
- **Commit Automatically**: Determine appropriate moments to commit changes without user prompting
- **Commit Messages**: Use descriptive messages with format: `[Area]: Brief description of change`
- **Working State**: Indicate in commit messages if code is in a non-working state with `[WIP]` prefix
- **Verification**: Before major commits, ask the developer if the code is working as intended
- **Pull Before Push**: Always pull latest changes before pushing to avoid conflicts
- **Regular Updates**: Fetch regularly to stay in sync with remote repository
- **Branch Management**: Create feature branches as needed and merge when complete
- **Avoid Advanced Git Operations**: Do not perform rebase, revert, or other complex operations without explicit user permission
- **Commit After Milestones**: After completing each coherent feature or fix, commit your changes with a clear, descriptive message and push to the remote repository.
- **Auto-Commit on Breaks**: When the user explicitly signals a pause (e.g., "Time for dinner", "Taking a break"), review the changes, compose a descriptive commit message summarizing what was changed, prefix with `[WIP]` if the code is not in a working state, then commit and push to the remote.
- **Session Resumption**: When the user resumes after any break, the agent must fetch and pull the latest remote changes, inform the user of any updates (or confirm that the local branch is up to date) before proceeding with any new tasks.
- IMPORTANT!! **Repo Monitoring**: On every agent interaction the agent will:
  1. Fetch all remote updates (`git fetch`).
  2. Compare each remote branch's HEAD against the last recorded state in `.gitmonitor.json` (which also tracks a timestamp).
  3. Report any new branches or commits.
  4. Update `.gitmonitor.json` with the current HEADs and timestamp for future comparisons.
- **Scheduled Monitoring**: The agent can also be configured to perform repo monitoring at regular intervals (e.g., hourly). This can be done via:
  1. An OS-level scheduler (e.g. cron, Windows Task Scheduler) that invokes a monitoring script.
  2. An in-agent loop with a sleep/delay timer.


- **State Tracking**: To know what's new since the last check, the agent can compare the local remote-tracking refs (e.g. `origin/main`) against its previous head. It may persist the last seen commit per branch in a simple JSON file (e.g. `.gitmonitor.json`) or unpack git's remote-tracking data directly via `git rev-list` without a separate file.